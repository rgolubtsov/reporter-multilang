/*
 * reporter-cli/sql-pdf/genie/src/controller_helper.vala
 * ============================================================================
 * Reporter Multilang. Version 0.5.9
 * ============================================================================
 * A tool to generate human-readable reports based on data from various sources
 * with the focus on its implementation using a series of programming languages
 * ============================================================================
 * Written by Radislav (Radicchio) Golubtsov, 2016-2024
 *
 * This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * (See the LICENSE file at the top of the source tree.)
 */

namespace CliSqlPdf {
/** The helper for the controller class and related ones. */
class ControllerHelper {
    // Helper constants.
    public const string _EMPTY_STRING    =   "";
    public const string _NEW_LINE        = "\n";
    public const string _S_FMT           = "%s";
    public const string _COLON_SPACE_SEP = ": ";
    public const string _COLON           =  ":";
    public const string _SLASH           =  "/";
    public const string _AT              =  "@";
    public const string _QM              =  "?";
    public const string _SQ              =  "'";
    public const string _V_BAR           =  "|";
    public const string _SPACE           =  " ";
    public const string _SEP_NOD         =  "+";
    public const string _SEP_COG         =  "-";
    public const string _CURRENT_DIR     = "./";

    // Common error messages.
    public const string _ERROR_PREFIX        = "Error";
    public const string _ERROR_NO_DB_CONNECT =
                         "Could not connect to the database. ";
    public const string _ERROR_NO_DATA       = "No data found.";
    public const string _ERROR_NO_REPORT_GEN =
                         "Could not generate the report.";

    /** Default constructor. */
    public ControllerHelper() {}
}

/**
 * This class is a simplified Vala implementation of well-known
 * and very attractive Text::TabularDisplay Perl module by Darren Chamberlain:
 * http://search.cpan.org/~darren/Text-TabularDisplay-1.38/TabularDisplay.pm .
 *
 * The output is identical to that generated by the MySQL/MariaDB CLI client
 * when doing something like 'select ... from ... where ...;' query
 * on a database table.
 *
 * See Valadoc comments in respective methods for their proper usage.
 */
class TabularDisplay {
    /** The table headers (headings). */
    string[ ] hdr_set;

    /** The table rows (table body data). */
    string[,] row_set;

    /**
     * The finally consolidated tabular data,
     * which has to be printed to the client.
     */
    string[ ] tableau;

    /**
     * Populates class data members with the given table data.
     *
     * @param _row_set The table rows (table body data).
     *                 (2D-array of strings.)
     */
    public void populate(string[,] _row_set) {
        var aux = new ControllerHelper();

        if (_row_set != null) {
            var num_rows = _row_set.length[0];
            var num_hdrs = _row_set.length[1];

            row_set = new string[num_rows,num_hdrs];

            row_set = _row_set;
// ----------------------------------------------------------------------------
            uint[ ] hdr_set_len = new uint[         num_hdrs];
            uint[,] row_set_len = new uint[num_rows,num_hdrs];
            uint[ ] col_max_len = new uint[num_rows         ];
// ----------------------------------------------------------------------------
            // Searching for the max data length in each column
            // to form its width.
            for (uint j = 0; j < num_hdrs; j++) {
                hdr_set_len[j] = hdr_set[j].length;

                for (uint i = 0; i < num_rows; i++) {
                    row_set_len[i,j] = row_set[i,j].length;
                }

                // Assuming this is the max.
                col_max_len[j] = row_set_len[0,j];

                // Searching for the max element in a column.
                for (uint i = 0; i < num_rows; i++) {
                    if (row_set_len[i,j] > col_max_len[j]) {
                        col_max_len[j] = row_set_len[i,j];
                    }
                }
            }
// ----------------------------------------------------------------------------
            _separator_draw(num_hdrs, hdr_set_len, col_max_len, aux);
// ----------------------------------------------------------------------------
            // Printing table headers.
            for (uint i = 0; i < num_hdrs; i++) {
//              stdout.printf(aux._S_FMT,aux._V_BAR + aux._SPACE + hdr_set[i]);
                tableau        +=        aux._V_BAR + aux._SPACE + hdr_set[i];

                uint spacers = 0;

                if (hdr_set_len[i] < col_max_len[i]) {
                    spacers = col_max_len[i] - hdr_set_len[i];
                }

                spacers++; // <== Additional spacer (padding).

                for (uint m = 0; m < spacers; m++) {
//                  stdout.printf(aux._S_FMT, aux._SPACE);
                    tableau        +=         aux._SPACE;
                }
            }

//          stdout.printf(aux._S_FMT, aux._V_BAR + aux._NEW_LINE);
            tableau        +=         aux._V_BAR + aux._NEW_LINE;
// ----------------------------------------------------------------------------
            _separator_draw(num_hdrs, hdr_set_len, col_max_len, aux);
// ----------------------------------------------------------------------------
            // Printing table rows.
            for (uint i = 0; i < num_rows; i++) {
                for (uint j = 0; j < num_hdrs; j++) {
//                stdout.printf(aux._S_FMT,aux._V_BAR+aux._SPACE+row_set[i,j]);
                  tableau        +=        aux._V_BAR+aux._SPACE+row_set[i,j];

                    if (col_max_len[j] < hdr_set_len[j]) {
                        col_max_len[j] = hdr_set_len[j];
                    }

                    uint spacers = 0;

                    if (row_set_len[i,j] < col_max_len[j]) {
                        spacers = col_max_len[j] - row_set_len[i,j];
                    }

                    spacers++; // <== Additional spacer (padding).

                    for (uint m = 0; m < spacers; m++) {
//                      stdout.printf(aux._S_FMT, aux._SPACE);
                        tableau        +=         aux._SPACE;
                    }
                }

//              stdout.printf(aux._S_FMT, aux._V_BAR + aux._NEW_LINE);
                tableau        +=         aux._V_BAR + aux._NEW_LINE;
            }
// ----------------------------------------------------------------------------
            _separator_draw(num_hdrs, hdr_set_len, col_max_len, aux);
// ----------------------------------------------------------------------------
        } else {
            row_set = {{},{}};
        }
    }

    /**
     * Renders class data into string representation,
     * which is ready to be printed to the client.
     *
     * @return The string representation of collected tabular data.
     */
    public string render() {
        var aux = new ControllerHelper();

        string tableau_str = aux._EMPTY_STRING;

        if (tableau != null) {
            for (uint i = 0; i < tableau.length; i++) {
                tableau_str += tableau[i];
            }
        }

        return tableau_str;
    }

    /* Helper method. Draws a horizontal separator for a table. */
    void _separator_draw(uint             num_hdrs,
                         uint[]           hdr_set_len,
                         uint[]           col_max_len,
                         ControllerHelper aux) {

        for (uint i = 0; i < num_hdrs; i++) {
//          stdout.printf(aux._S_FMT, aux._SEP_NOD);
            tableau        +=         aux._SEP_NOD;

            uint sep_len = hdr_set_len[i];

            if (sep_len < col_max_len[i]) {
                sep_len = col_max_len[i];
            }

            sep_len += 2; // <== Two additional separator cogs (padding).

            for (uint m = 0; m < sep_len; m++) {
//              stdout.printf(aux._S_FMT, aux._SEP_COG);
                tableau        +=         aux._SEP_COG;
            }
        }

//      stdout.printf(aux._S_FMT, aux._SEP_NOD + aux._NEW_LINE);
        tableau        +=         aux._SEP_NOD + aux._NEW_LINE;
    }

    /**
     * Constructor. It takes one argument and returns an object instance
     *              of this class.
     *
     * @param _hdr_set The table headers (headings).
     *                 (Simple array of strings.)
     */
    public TabularDisplay(string[] _hdr_set) {
        if (_hdr_set != null) {
            hdr_set.resize(_hdr_set.length);

            hdr_set = _hdr_set;
        } else {
            hdr_set = {};
        }
    }
}
} // namespace CliSqlPdf

// vim:set nu et ts=4 sw=4:
